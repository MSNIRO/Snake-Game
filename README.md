Snake Project (Team Cobra) 

رابط المشروع في github : 

https://github.com/MSNIRO/Snake-Game.git 

 

 كيفية اللعب: 

التحكم في اللعبة : 

* W - للتحرك إلى الأعلى 

* S - للتحرك إلى الأسفل 

* A - للتحرك إلى اليسار 

* D - للتحرك إلى اليمين 

* P - لإيقاف اللعبة مؤقتًا أو استئنافها

* q - للخروج من اللعبة

الهدف هو توجيه الثعبان (الرأس O)   و (الجسم o)  لأكل الطعام (x). 

 

قواعد اللعبة: 

* البداية: تبدأ اللعبة بثعبان صغير الحجم في وسط الشاشة. 

* النمو والنقاط: كلما أكل الثعبان طعامًا يزداد طوله وتتم إضافة 10 نقاط إلى رصيدك. 

* زيادة السرعة: تزداد سرعة اللعبة تدريجيًا كل 30 نقطة لتحافظ على التحدي. 

* الالتفاف حول الشاشة: إذا وصل الثعبان إلى إحدى حواف الشاشة، فإنه يظهر من الجهة المقابلة. 

* نهاية اللعبة: تنتهي اللعبة (Game Over) إذا اصطدم رأس الثعبان بأي جزء من جسده. 

* النتيجة الأعلى: يتم حفظ أعلى نتيجة تصل إليها في ملف highscore.txt لعرضها في كل مرة تلعب فيها. 

️ 

 كيف يعمل الكود 

تم بناء المشروع باستخدام البرمجة كائنية التوجه (OOP) لتقسيم الكود وتنظيمه، مما يجعله أكثر قابلية للقراءة والصيانة. يتكون المشروع من ثلاث فئات (Classes) رئيسية: 

1. Class Game 

هذه هي الفئة الرئيسية التي تدير اللعبة بأكملها. 

* الملفات: game.h, game.cpp 

* مسؤولياتها: 

   * إدارة حلقة اللعبة (Game Loop): تحتوي على الدالة Run() التي تستمر في العمل حتى تنتهي اللعبة. 

   * الرسم على الشاشة (Draw): تقوم بمسح الشاشة ورسم حدود الملعب، الثعبان، والطعام في كل إطار (frame). 

   * معالجة المدخلات (Input): تستقبل أوامر التحكم من اللاعب (W, A, S, D) لتغيير اتجاه الثعبان. 

   * منطق اللعبة (Logic): تقوم بتحديث حالة اللعبة، مثل تحريك الثعبان، والتحقق مما إذا كان الثعبان قد أكل الطعام، والتحقق من حدوث اصطدام. 

   * إدارة النقاط والسرعة: تحسب نقاط اللاعب وتزيد من سرعة اللعبة بناءً على النقاط. 

   * حفظ واستدعاء أعلى نتيجة: تقرأ وتكتب في ملف highscore.txt. 

2. Class Snake 

تمثل هذه الفئة الثعبان نفسه. 

* الملفات: snake.h, snake.cpp 

* مسؤولياتها: 

   * تخزين جسم الثعبان: تستخدم std::vector من الأزواج (std::pair<int, int>) لتخزين إحداثيات كل جزء من أجزاء جسم الثعبان. 

   * الحركة (Move): تقوم بتحريك الثعبان عن طريق إضافة رأس جديد في اتجاه الحركة وحذف آخر جزء من الذيل (إلا إذا كان الثعبان في حالة نمو). 

   * تغيير الاتجاه (ChangeDirection): تسمح بتغيير اتجاه حركة الثعبان مع منع الحركة للخلف مباشرة (180 درجة). 

   * النمو (Grow): عند أكل الطعام، تمنع هذه الدالة حذف ذيل الثعبان في دورة الحركة التالية، مما يؤدي إلى زيادة طوله. 

   * التحقق من الاصطدام (CheckCollision): تتحقق مما إذا كان رأس الثعبان قد اصطدم بأي جزء آخر من جسده. 

3. Class Food 

تدير هذه الفئة كل ما يتعلق بالطعام. 

* الملفات: food.h, food.cpp 

* مسؤولياتها: 

   * تخزين موقع الطعام: تحتفظ بإحداثيات موقع الطعام الحالي. 

   * إعادة توليد الطعام (foodrespawn): عند أكل الطعام، تقوم هذه الدالة بتوليد طعام جديد في موقع عشوائي على الشاشة. الأهم من ذلك، أنها تتأكد من أن الموقع الجديد لا يقع على جسم الثعبان. 

   * التحقق من الأكل (IsEaten): تتحقق مما إذا كانت إحداثيات رأس الثعبان تتطابق مع إحداثيات الطعام. 

 

كيفية تشغيل اللعبة: 

نستخدم األمر التالي في التيرمنال: 

g++ main.cpp game.cpp snake.cpp food.cpp -o SnakeGame.exe 

ثم نشغل الملف SnakeGame.exe. 

 

 

 المشاكل التي واجهناها وحللناها: 

مشكلة: استقبال مدخلات المستخدم دون إيقاف اللعبة 

* التحدي: دوال الإدخال القياسية في C++ (مثل std::cin) توقف تنفيذ البرنامج حتى يضغط المستخدم على Enter. هذا لا يناسب لعبة تحتاج إلى حركة مستمرة. 

* الحل: استخدمنا دوال من مكتبة <conio.h> الخاصة بنظام ويندوز. 

   * _kbhit(): تتحقق مما إذا كان هناك مفتاح تم الضغط عليه دون إيقاف البرنامج. 

   * _getch(): تقرأ المفتاح الذي تم الضغط عليه فورًا. 

     بهذه الطريقة، تستمر حلقة اللعبة في العمل بسلاسة، ويتم فحص المدخلات في كل إطار. 

مشكلة: ظهور الطعام فوق جسم الثعبان 

* التحدي: عند توليد طعام جديد في موقع عشوائي، كان من الممكن أن يظهر في مكان يحتله الثعبان بالفعل، مما يجعله غير قابل للأكل. 

 

الحل: في دالة foodrespawn، بعد توليد إحداثيات عشوائية للطعام، قمنا بإضافة حلقة for تمر على كل جزء من جسم الثعبان. إذا كانت إحداثيات الطعام الجديدة تتطابق مع أي جزء من الثعبان، يتم تجاهل هذه الإحداثيات وتوليد إحداثيات جديدة. تستمر هذه العملية حتى يتم العثور على مكان فارغ. مشكلة: منع الثعبان من الاصطدام بنفسه فورًا 

 

التحدي: إذا كان الثعبان يتحرك يمينًا (D) وضغط اللاعب على زر اليسار (A)، فسيصطدم الثعبان برقبته فورًا وتنتهي اللعبة.  

 

الحل: في دالة ChangeDirection، أضفنا شرطًا يتحقق من الاتجاه الحالي قبل تغيير الاتجاه الجديد. يتم قبول الاتجاه الجديد فقط إذا لم يكن عكس الاتجاه الحالي تمامًا. على سبيل المثال، إذا كان الاتجاه هو UP، فسيتم تجاهل DOWN ولكن قبول LEFT و RIGHT. مشكلة: إنشاء وهم الحركة على شاشة ثابتة 

 

التحدي: واجهة الأوامر هي شاشة ثابتة. كيف يمكننا إنشاء رسوم متحركة؟ 

الحل: اتبعنا تقنية الرسم إطارًا بإطار (frame-by-frame). في كل دورة من حلقة اللعبة الرئيسية: 

يتم مسح الشاشة بالكامل باستخدام system("cls"). 

يتم إعادة رسم كل شيء من جديد (الحدود، الثعبان، الطعام) في مواقعهم المحدثة باستخدام دالة Draw. 

يتم إيقاف التنفيذ لجزء صغير من الثانية باستخدام Sleep() للتحكم في سرعة اللعبة.هذا التكرار السريع يعطي اللاعب انطباعًا بالحركة السلسة  

 

 

 

 

 

 لجعل هذا الكود يعمل على أنظمة أخرى، يجب استبدال هذه الأجزاء  

 

 

      1.مسح الشاشة: استبدال system("cls"); بالاتي 

      system("clear")  

 

      2.الإيقاف المؤقت: استبدال Sleep(speed); بالآتي، مع الحاجة لتضمين مكتبة <unistd.h>  

#include <unistd.h> 

 usleep(speed * 1000); 

 

3. المدخلات: استبدال _kbhit() و _getch() يتطلب معالجة معقدة لوضع الطرفية (terminal)
في أنظمة Linux/macOS باستخدام مكتبة <termios.h> لتحويلها من الوضع القياسي   (canonical mode) إلى الوضع غير القياسي، مما يسمح بقراءة كل حرف على حدة دون انتظار الضغط على Enter. 

 

 

4.الألوان: استبدال SetColor() يتطلب استخدام أكواد ANSI Escape Codes، وهي سلاسل نصية خاصة تقوم بتغيير لون النص في الطرفية. هذه الطريقة ممكنة ولكنها معقدة وتجعل الكود صعب القراءة والصيانة. 
